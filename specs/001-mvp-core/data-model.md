# Data Model Specification

**Feature**: Writing Timeline Platform MVP
**Date**: 2025-10-18
**Database**: PostgreSQL 15+ (Supabase)

## Overview

Event sourcing architecture with three core entities:
1. **Documents** - User's writing documents
2. **Writing Events** - Immutable event log (insert/delete/replace)
3. **Checkpoints** - Periodic snapshots for playback optimization

## Database Schema

### 1. users (Supabase Auth managed)

Managed by Supabase Auth. Fields available via `auth.users`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Auto-generated by Supabase |
| email | VARCHAR(255) | UNIQUE, NOT NULL | User email |
| created_at | TIMESTAMP | DEFAULT NOW() | Account creation |
| updated_at | TIMESTAMP | DEFAULT NOW() | Last update |

**Note**: Username stored in `public.profiles` table (see below)

### 2. profiles

Extended user profile information (1:1 with auth.users)

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username VARCHAR(50) UNIQUE NOT NULL,
  display_name VARCHAR(100),
  bio TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public profiles are viewable by everyone"
  ON profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  USING (auth.uid() = id);
```

### 3. documents

Main document table with metadata

```sql
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
  visibility VARCHAR(20) DEFAULT 'private' CHECK (visibility IN ('private', 'public', 'unlisted')),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  published_at TIMESTAMP,
  first_version_content TEXT, -- Cached first version for diff
  final_content TEXT, -- Cached latest version for reading
  event_count INTEGER DEFAULT 0, -- Denormalized count for UI
  writing_duration_ms BIGINT DEFAULT 0, -- Total writing time (for stats)

  -- Constraints
  CONSTRAINT title_not_empty CHECK (char_length(title) > 0),
  CONSTRAINT content_length CHECK (char_length(final_content) <= 50000)
);

-- Indexes
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_documents_visibility ON documents(visibility);
CREATE INDEX idx_documents_published_at ON documents(published_at) WHERE published_at IS NOT NULL;

-- RLS Policies
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Owner can do anything with their documents
CREATE POLICY "Users can manage own documents"
  ON documents FOR ALL
  USING (auth.uid() = user_id);

-- Public documents readable by anyone
CREATE POLICY "Public documents are viewable by everyone"
  ON documents FOR SELECT
  USING (visibility = 'public' AND status = 'published');

-- Unlisted documents readable by anyone with link
CREATE POLICY "Unlisted documents are viewable with direct link"
  ON documents FOR SELECT
  USING (visibility = 'unlisted' AND status = 'published');
```

**Field Details**:
- `first_version_content`: Denormalized for diff performance (reconstructed from first N events on publish)
- `final_content`: Denormalized for reader view performance (avoids event replay)
- `event_count`: Used for checkpoint strategy (create checkpoint every 1000 events)
- `writing_duration_ms`: Calculated as `MAX(timestamp) - MIN(timestamp)` from events

### 4. writing_events

Immutable event log (append-only)

```sql
CREATE TABLE writing_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  session_id UUID NOT NULL, -- Browser session identifier
  timestamp BIGINT NOT NULL, -- Unix timestamp in milliseconds
  event_type VARCHAR(20) NOT NULL CHECK (event_type IN ('insert', 'delete', 'replace')),
  position INTEGER NOT NULL CHECK (position >= 0), -- Cursor position
  content TEXT, -- Inserted/new content
  content_before TEXT, -- Deleted/old content (for delete/replace)
  created_at TIMESTAMP DEFAULT NOW(), -- Server insert time

  -- Constraints
  CONSTRAINT position_within_limit CHECK (position <= 50000)
);

-- Indexes (CRITICAL for performance)
CREATE INDEX idx_events_document_timestamp ON writing_events(document_id, timestamp);
CREATE INDEX idx_events_document_id ON writing_events(document_id);
CREATE INDEX idx_events_session_id ON writing_events(session_id);

-- RLS Policies
ALTER TABLE writing_events ENABLE ROW LEVEL SECURITY;

-- Only document owner can insert events
CREATE POLICY "Users can insert events for own documents"
  ON writing_events FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM documents
      WHERE documents.id = document_id AND documents.user_id = auth.uid()
    )
  );

-- Events readable if document is readable
CREATE POLICY "Events readable if document is readable"
  ON writing_events FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM documents
      WHERE documents.id = document_id
      AND (
        documents.user_id = auth.uid() -- Owner
        OR (documents.visibility IN ('public', 'unlisted') AND documents.status = 'published') -- Public
      )
    )
  );
```

**Event Type Semantics**:
- `insert`: Add text at position
  - `content`: Text to insert
  - `content_before`: NULL
- `delete`: Remove text from position
  - `content`: NULL
  - `content_before`: Deleted text (for undo support)
- `replace`: Replace selection
  - `content`: New text
  - `content_before`: Replaced text

### 5. checkpoints

Periodic snapshots for playback optimization

```sql
CREATE TABLE checkpoints (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  event_id UUID NOT NULL REFERENCES writing_events(id) ON DELETE CASCADE, -- Event after which snapshot was taken
  event_index INTEGER NOT NULL, -- Nth event (0-indexed)
  timestamp BIGINT NOT NULL, -- Same as event.timestamp for this checkpoint
  content_snapshot TEXT NOT NULL, -- Full document content at this point
  created_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT checkpoint_every_1000 CHECK (event_index % 1000 = 0)
);

-- Indexes
CREATE INDEX idx_checkpoints_document ON checkpoints(document_id, event_index DESC);
CREATE INDEX idx_checkpoints_timestamp ON checkpoints(document_id, timestamp DESC);

-- RLS Policies
ALTER TABLE checkpoints ENABLE ROW LEVEL SECURITY;

-- Checkpoints readable if document is readable
CREATE POLICY "Checkpoints readable if document is readable"
  ON checkpoints FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM documents
      WHERE documents.id = document_id
      AND (
        documents.user_id = auth.uid()
        OR (documents.visibility IN ('public', 'unlisted') AND documents.status = 'published')
      )
    )
  );

-- Only system (via service role) can create checkpoints
CREATE POLICY "System can create checkpoints"
  ON checkpoints FOR INSERT
  WITH CHECK (true); -- Restricted to service_role key in code
```

## Denormalization Strategy

### Why Denormalize?

| Denormalized Field | Reason | Recalculation Trigger |
|--------------------|--------|----------------------|
| `documents.first_version_content` | Diff viewer performance | On publish (once) |
| `documents.final_content` | Reader view performance | After each event batch |
| `documents.event_count` | Checkpoint creation trigger | After each event insert |
| `documents.writing_duration_ms` | Stats display | On publish (once) |
| `checkpoints.content_snapshot` | Playback performance | Every 1000 events |

### Update Triggers

```sql
-- Update final_content and event_count after event insert
CREATE OR REPLACE FUNCTION update_document_after_event()
RETURNS TRIGGER AS $$
BEGIN
  -- Increment event count
  UPDATE documents
  SET event_count = event_count + 1,
      updated_at = NOW()
  WHERE id = NEW.document_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_document_after_event
AFTER INSERT ON writing_events
FOR EACH ROW
EXECUTE FUNCTION update_document_after_event();
```

**Note**: `final_content` will be updated via application code (not trigger) to avoid reconstructing document on every single event. Instead, update after event batches (50 events).

## Data Integrity Rules

### Invariants

1. **Event Immutability**: `writing_events` rows never updated/deleted (only INSERT allowed)
2. **Timestamp Monotonicity**: Events for same document must have increasing timestamps
3. **Position Validity**: `position` must be within `[0, current_content_length]`
4. **Content Length**: Final content must not exceed 50,000 characters

### Validation (Application Layer)

```typescript
// Before inserting event
function validateEvent(event: WritingEvent, currentContent: string) {
  if (event.position > currentContent.length) {
    throw new Error('Position out of bounds');
  }

  if (event.type === 'insert') {
    const newLength = currentContent.length + event.content.length;
    if (newLength > 50000) {
      throw new Error('Document exceeds 50,000 character limit');
    }
  }
}
```

## Query Patterns

### 1. Get all events for playback

```sql
-- Full playback (with checkpoint optimization)
WITH nearest_checkpoint AS (
  SELECT content_snapshot, event_index
  FROM checkpoints
  WHERE document_id = $1
  ORDER BY event_index DESC
  LIMIT 1
)
SELECT e.*
FROM writing_events e
LEFT JOIN nearest_checkpoint cp ON TRUE
WHERE e.document_id = $1
  AND (cp.event_index IS NULL OR e.event_index > cp.event_index)
ORDER BY e.timestamp ASC;
```

### 2. Get events in time range

```sql
-- Playback from timestamp T1 to T2
SELECT *
FROM writing_events
WHERE document_id = $1
  AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp ASC;
```

### 3. Rebuild document at timestamp T

```typescript
// Application code (with checkpoint)
async function getDocumentAtTimestamp(documentId: string, targetTimestamp: number) {
  // 1. Find nearest checkpoint before timestamp
  const checkpoint = await supabase
    .from('checkpoints')
    .select('content_snapshot, timestamp')
    .eq('document_id', documentId)
    .lte('timestamp', targetTimestamp)
    .order('timestamp', { ascending: false })
    .limit(1)
    .single();

  let content = checkpoint?.content_snapshot || '';
  const startTimestamp = checkpoint?.timestamp || 0;

  // 2. Replay events after checkpoint
  const { data: events } = await supabase
    .from('writing_events')
    .select('*')
    .eq('document_id', documentId)
    .gt('timestamp', startTimestamp)
    .lte('timestamp', targetTimestamp)
    .order('timestamp');

  for (const event of events) {
    content = applyEvent(content, event);
  }

  return content;
}
```

## IndexedDB Schema (Client-Side)

For offline queue and caching:

```typescript
import Dexie, { Table } from 'dexie';

interface LocalEvent {
  id?: number; // Auto-increment
  documentId: string;
  sessionId: string;
  timestamp: number;
  eventType: 'insert' | 'delete' | 'replace';
  position: number;
  content?: string;
  contentBefore?: string;
  synced: boolean; // false until sent to server
}

interface LocalDocument {
  id: string;
  title: string;
  content: string;
  updatedAt: number;
}

class WritingTimelineDB extends Dexie {
  events!: Table<LocalEvent, number>;
  documents!: Table<LocalDocument, string>;

  constructor() {
    super('WritingTimelineDB');

    this.version(1).stores({
      events: '++id, documentId, timestamp, [documentId+timestamp], synced',
      documents: 'id, updatedAt'
    });
  }
}

export const db = new WritingTimelineDB();
```

## Migration Strategy

### Initial Migration

```sql
-- File: supabase/migrations/001_initial_schema.sql
-- (Contains all CREATE TABLE statements above)
```

### Future Migrations

```sql
-- Example: Add tags feature (Phase 2)
-- File: supabase/migrations/002_add_tags.sql
CREATE TABLE tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(document_id, name)
);
```

## Performance Estimates

### Storage

| Entity | Row Size (avg) | 1k Documents | 100k Events |
|--------|---------------|--------------|-------------|
| documents | 2 KB | 2 MB | 2 MB |
| writing_events | 0.5 KB | - | 50 MB |
| checkpoints | 10 KB | - | 1 MB |
| **Total** | - | ~50 MB | ~50 MB |

### Query Performance (with indexes)

| Query | Without Index | With Index | Target |
|-------|--------------|------------|--------|
| Get document events | O(n) ~1s | O(log n) <50ms | < 100ms |
| Playback range | O(n) ~500ms | O(log n + k) <20ms | < 50ms |
| Find checkpoint | O(m) ~100ms | O(log m) <5ms | < 10ms |

## Next Steps

1. ✅ Data model complete
2. ⏭️ Generate API contracts (OpenAPI specs)
3. ⏭️ Write quickstart.md (migration setup)
